import torch
import torch.nn.functional as F
from torch_geometric.nn import GCNConv
from torch_geometric.data import Data, DataLoader
import random

# Sample function to generate CFG data from a malware binary
def generate_CFG(binary_path, num_samples=1000):
    data_list = []

    for _ in range(num_samples):  # Fixed syntax error in loop
        num_nodes = random.randint(5, 20)  # Fixed missing assignment operator
        nodes = torch.randn((num_nodes, 2))  # Creating random node features
        edges = torch.randint(0, num_nodes, (2, random.randint(num_nodes - 1, (num_nodes * (num_nodes - 1)) // 2)))  # Fixed missing argument and parenthesis

        # Randomly assign a Label (0: benign, 1: metamorphic malware)
        label = torch.tensor([random.randint(0, 1)], dtype=torch.long)  # Fixed tensor creation

        data = Data(x=nodes, edge_index=edges, y=label)
        data_list.append(data)

    return data_list


# Define the GNN model
class GNNModel(torch.nn.Module):
    def __init__(self):  # Fixed constructor initialization
        super(GNNModel, self).__init__()
        self.conv1 = GCNConv(2, 16)  # Input feature size is 2, output feature size is 16
        self.conv2 = GCNConv(16, 2)  # Input feature size is 16, output feature size is 2

    def forward(self, data):
        x, edge_index = data.x, data.edge_index  # Corrected variable names and unpacking
        x = self.conv1(x, edge_index)  # Apply first GCN layer
        x = F.relu(x)  # Apply ReLU activation
        x = F.dropout(x, training=self.training)  # Apply dropout

        x = self.conv2(x, edge_index)  # Apply second GCN layer
        return F.log_softmax(x, dim=1)  # Return log-softmax for classification


# Generate CFG data from hypothetical malware binaries
dataset = generate_CFG("path_to_malware_binary")

# Use DataLoader to load the dataset in batches
loader = DataLoader(dataset, batch_size=32, shuffle=True)

# Initialize and train the GNN model
model = GNNModel()
optimizer = torch.optim.Adam(model.parameters(), lr=0.01)  # Corrected 'Ir' to 'lr'

model.train()
for epoch in range(100):
    for data in loader:
        optimizer.zero_grad()  # Zero the gradients
        out = model(data)  # Forward pass

        # Adjust the Loss calculation for batched graph data using the batch attribute
        y_true = data.y[data.batch]  # Get the true labels for the batch
        loss = F.nll_loss(out, y_true)  # Calculate the loss using negative log likelihood loss

        loss.backward()  # Backward pass
        optimizer.step()  # Update the model weights

# Inference on a single sample
model.eval()
sample_data = dataset[0]  # Fixed typo in variable name
out = model(sample_data)

# Make prediction based on the output
pred = out.max(dim=1)[1]  # Get the predicted class

# Check if the first node in the binary is detected as metamorphic malware
if pred[0].item() == 1:
    print("The first node in the binary is detected as metamorphic malware!")
else:
    print("The first node in the binary is benign.")
